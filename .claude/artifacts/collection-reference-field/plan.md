# Implementation Plan: CollectionReferenceField — DnD Reorder + Pagination Type

## Spec Reference

[./spec.md](../../specs/collection-reference-field.md)

## Codebase Context

### Current State

- **Component:** `src/features/payload-admin/components/collection-reference-field.tsx` (152 lines) — single file, mixes filter logic, data fetching, and rendering
- **Field config:** `src/features/payload-admin/fields/collection-reference-field.ts` (60 lines) — factory function `createCollectionReferenceField()` that creates Payload UI field with `clientProps`
- **Data hook:** `src/shared/hooks/use-collection-data.ts` (29 lines) — React Query wrapper around `payloadAPI.getCollectionWithPagination()`
- **DataTable:** `src/shared/components/data-table/data-table.tsx` (177 lines) — supports controlled/uncontrolled pagination, custom columns, actions
- **API client:** `src/shared/lib/payload-rest.ts` (105 lines) — axios-based, returns `{ docs, totalDocs, hasNextPage, ... }`

### Key Patterns

- Payload resolves components via import path in `admin.components.Field.path` — format: `@/path/to/file#ExportName`
- `importMap.js` is auto-generated by Payload from these paths — will regenerate when path changes
- `useCollectionData` doesn't support `sort` param yet — needs to be added
- `DataTable` always renders `<Pagination>` — no way to hide it currently
- No DnD libraries in `package.json` — `@dnd-kit` must be installed fresh
- Existing blocks (doctors, prices, feedbacks, FAQ, contact, etc.) all use `createCollectionReferenceField()` — none pass `reorderable` or `paginationType` today

### Constraints

- Component path in `fields/collection-reference-field.ts` line 45 must point to a file that has a named export `CollectionReferenceField` — after decomposition, the `index.ts` re-export satisfies this
- `@dnd-kit/sortable` wraps individual items with `useSortable` — requires each row to have a unique `id`
- Payload REST API supports `sort` as a query param (e.g., `sort=sortOrder` or `sort=-createdAt`)
- PATCH to `/api/{collection}/{id}` updates individual items — no batch update endpoint

## Implementation Steps

### Step 1: Install `@dnd-kit` packages

**Action:** Install new dependencies
**Command:** `pnpm add @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities`
**Details:**
- Three packages needed: `@dnd-kit/core` (DnD engine), `@dnd-kit/sortable` (sortable preset), `@dnd-kit/utilities` (CSS transform helper)
- These are peer-compatible with React 19

**Rationale:** Spec requires `@dnd-kit` — it's the modern standard for React DnD, lightweight and accessible. No existing DnD library in the project.

---

### Step 2: Add `sort` param support to `useCollectionData`

**Action:** Modify existing file
**File:** `src/shared/hooks/use-collection-data.ts` (existing)
**Details:**
- Add optional `sort?: string` to `UseCollectionDataParams` interface
- Pass `sort` through to `payloadAPI.getCollectionWithPagination()` params
- Include `sort` in the `queryKey` array for proper cache invalidation

**Rationale:** The hook currently doesn't support sorting. Reorder feature requires `sort=sortOrder` to fetch data in the persisted order. Adding it to the shared hook keeps it generic and reusable.

---

### Step 3: Add `hidePagination` prop to `DataTable`

**Action:** Modify existing files
**Files:**
- `src/shared/components/data-table/types.ts` (existing) — add `hidePagination?: boolean` to `DataTableProps`
- `src/shared/components/data-table/data-table.tsx` (existing) — conditionally render `<Pagination>` based on `hidePagination`

**Details:**
- Add `hidePagination?: boolean` to `DataTableProps` interface
- In `DataTable`, destructure `hidePagination` and wrap the `<Pagination>` render in `{!hidePagination && <Pagination ... />}`

**Rationale:** The `load-more` pagination type needs to hide the standard pagination controls. Rather than building a completely separate table, a simple prop on `DataTable` keeps the existing component reusable. This is a minimal, non-breaking change — default behavior is unchanged.

---

### Step 4: Create `types.ts` — shared types for the component

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/types.ts` (new)
**Details:**
- Move `CollectionReferenceFieldProps` interface here (from the current component file)
- Add new props: `reorderable?: boolean`, `paginationType?: 'page' | 'load-more'`
- Export the interface

```typescript
interface CollectionReferenceFieldProps {
  collectionSlug: string;
  title: string;
  description?: string;
  showTable?: boolean;
  columns?: CollectionReferenceFieldColumn[];
  pageSize?: number;
  filters?: Record<string, string>;
  reorderable?: boolean;
  paginationType?: 'page' | 'load-more';
}
```

**Rationale:** Centralizes types for the feature folder. Multiple files (main component, hooks) need access to these types.

---

### Step 5: Create `use-collection-reference.ts` — extract filter + fetch logic

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/use-collection-reference.ts` (new)
**Details:**
- Extract the `whereCondition` useMemo logic from the current component (lines 43-74)
- Extract the `useCollectionData` call (lines 76-82)
- Accept params: `{ collectionSlug, filters, pageSize, page, showTable, reorderable }`
- When `reorderable` is true, pass `sort: 'sortOrder'` to `useCollectionData`
- Return `{ data, totalDocs, hasNextPage, isLoading, refetch }`
- Uses `useDocumentInfo` and `useAllFormFields` from `@payloadcms/ui` internally (same as current component)

**Rationale:** Separates data-fetching concern from rendering. The current component mixes filter building, API calls, and UI — this hook encapsulates the first two. Adds `sort` param for reorder support.

---

### Step 6: Create `use-load-more.ts` — page accumulation hook

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/use-load-more.ts` (new)
**Details:**
- Hook params: `{ collectionSlug, filters, pageSize, showTable, reorderable }` (same base params as `use-collection-reference`)
- Internally manages `page` state (starts at 1)
- Calls `useCollectionReference` with current page
- Accumulates `docs` across pages into a single array using `useRef` + `useEffect`
- Resets accumulated data when `filters` change (via effect that watches whereCondition)
- Exposes: `{ items, hasNextPage, isLoadingMore, loadMore, totalItems, isLoading }`
- `loadMore()` increments page state

**Rationale:** Encapsulates the "load more" pattern — accumulating pages into a growing list. Keeps this logic separate from the main component and from the standard pagination path.

---

### Step 7: Create `use-reorder.ts` — DnD state + persist logic

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/use-reorder.ts` (new)
**Details:**
- Hook params: `{ items, collectionSlug, onReorderComplete }` where `items` is the current data array
- Sets up `@dnd-kit` sensors: `useSensor(PointerSensor)` with activation constraint (distance: 8px to avoid accidental drags)
- Manages local `orderedItems` state (copy of items, reordered optimistically on drag end)
- `onDragEnd` handler: uses `arrayMove` from `@dnd-kit/sortable` to reorder the local state
- After reorder: calculates new `sortOrder` values (simple sequential: 0, 1, 2, ...) for affected items
- Sends PATCH requests via `payloadAPI` (or direct axios) to `/{collection}/{id}` with `{ sortOrder }` body
- Uses `Promise.allSettled` to handle partial failures
- Manages `isSaving` state — true while PATCH requests are in flight
- On success: calls `onReorderComplete` (triggers refetch)
- On failure: shows `toast.error()` (or console.error if no toast available), calls `onReorderComplete` to refetch server state
- Exposes: `{ orderedItems, sensors, onDragEnd, isSaving, activeId }` where `activeId` tracks currently dragged item

**Rationale:** Isolates all DnD logic — sensors, handlers, persistence — into a single hook. The component doesn't need to know about `@dnd-kit` internals. Uses `Promise.allSettled` over `Promise.all` for graceful partial failure handling.

---

### Step 8: Create `reorderable-table.tsx` — DnD-wrapped table

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/reorderable-table.tsx` (new)
**Details:**
- Wraps `DataTable` content with `DndContext` + `SortableContext` from `@dnd-kit`
- **Cannot wrap the existing `DataTable` directly** because `@dnd-kit/sortable` needs `useSortable` on each row element — but `DataTable` renders its own `<tr>` elements internally
- Instead, this component renders its own `<table>` structure (similar to `DataTable` but with sortable rows):
  - Reuses `DataTableColumn` types and rendering pattern from `DataTable`
  - Each `<tr>` is wrapped with `useSortable` hook
  - First column is a drag handle (GripVertical icon from `lucide-react`)
  - `DragOverlay` renders a styled copy of the dragged row
- Receives: `{ items, columns, actions, isSaving, sensors, onDragEnd, activeId }`
- When `isSaving` is true: shows a subtle overlay/opacity + disables drag handles
- Uses `restrictToVerticalAxis` modifier from `@dnd-kit/core` to constrain drag direction
- Each item must have an `id` field (standard Payload document field)

**Rationale:** `@dnd-kit/sortable` requires direct control over the DOM elements that become sortable. Since `DataTable` encapsulates its own `<tr>` rendering, we can't inject `useSortable` into it without modifying the shared component. A dedicated reorderable table component keeps the shared `DataTable` clean and unchanged while providing full DnD support. This component reuses the same column/action rendering patterns from `DataTable` for consistency.

---

### Step 9: Create `load-more-button.tsx` — load more UI

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/load-more-button.tsx` (new)
**Details:**
- Simple component: `{ onClick, isLoading }` props
- Renders a `Button` (reuse from `@/shared/components/ui-kit/button`) with `variant="admin-secondary"`
- Shows spinner (same pattern as `DataTable` loading state) when `isLoading` is true
- Text: "Завантажити ще" (Ukrainian, consistent with existing UI language)

**Rationale:** Small, focused component. Keeps the main component clean. Reuses existing `Button` from shared UI kit.

---

### Step 10: Create `collection-reference-field.tsx` — composition root

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/collection-reference-field.tsx` (new)
**Details:**
- Composition-only component — delegates to hooks and sub-components
- Destructures all props from `CollectionReferenceFieldProps` (including new `reorderable`, `paginationType`)
- Logic flow:
  1. If `paginationType === 'load-more'`: use `useLoadMore` hook
  2. Else: use standard pagination with `useCollectionReference` hook + local `currentPage` state
  3. If `reorderable`: use `useReorder` hook and render `ReorderableTable`
  4. Else: render standard `DataTable`
- Renders the same header/manage-link UI as current component (lines 109-127)
- Conditionally renders either `ReorderableTable` or `DataTable` below
- For `load-more` mode: renders `LoadMoreButton` after the table (when `hasNextPage`)
- For `load-more` mode: passes `hidePagination={true}` to `DataTable`
- `DataTable` actions (edit in new tab) stay the same

**Rationale:** Keeps the main component as a thin composition layer. All logic is delegated to purpose-built hooks. Branching on `reorderable` and `paginationType` is the only conditional logic here.

---

### Step 11: Create `index.ts` — public API

**Action:** Create new file
**File:** `src/features/payload-admin/components/collection-reference-field/index.ts` (new)
**Details:**
- Re-export `CollectionReferenceField` from `./collection-reference-field`
- Re-export types if needed externally

```typescript
export { CollectionReferenceField } from './collection-reference-field';
```

**Rationale:** Maintains the same export path pattern. Payload's component resolution via `#CollectionReferenceField` will work with the folder's `index.ts`.

---

### Step 12: Delete old single-file component

**Action:** Delete file
**File:** `src/features/payload-admin/components/collection-reference-field.tsx` (existing — delete)
**Details:**
- Remove the old single-file component
- The new folder `collection-reference-field/index.ts` takes its place
- Import paths like `@/features/payload-admin/components/collection-reference-field` resolve to the folder's `index.ts` — **no import changes needed** in consuming code

**Rationale:** The folder replaces the single file. TypeScript/Node module resolution resolves `collection-reference-field` to `collection-reference-field/index.ts` automatically.

---

### Step 13: Update field config with new options

**Action:** Modify existing file
**File:** `src/features/payload-admin/fields/collection-reference-field.ts` (existing)
**Details:**
- Add `reorderable?: boolean` and `paginationType?: 'page' | 'load-more'` to `CollectionReferenceFieldOptions` interface
- Pass these through to `clientProps` in the factory function
- The component `path` stays the same: `@/features/payload-admin/components/collection-reference-field#CollectionReferenceField` — still resolves correctly (folder index.ts)

**Rationale:** Enables consumers (block configs) to opt into new features via the existing factory function. No path change needed since module resolution handles folder → index.ts.

---

### Step 14: Regenerate Payload importMap

**Action:** Run command
**Command:** `pnpm payload generate:importmap` (or equivalent — check `package.json` scripts)
**Details:**
- Payload auto-generates `src/app/(payload)/admin/importMap.js` based on component paths
- Since the export name and path haven't changed conceptually (still `@/features/payload-admin/components/collection-reference-field#CollectionReferenceField`), the importMap should regenerate cleanly
- Verify the generated importMap resolves correctly

**Rationale:** Payload requires the importMap to be regenerated whenever component paths change. Even though the path string is the same, the underlying file changed from `.tsx` to a folder with `index.ts`.

---

### Step 15: Verify existing blocks work unchanged

**Action:** Manual verification
**Details:**
- Ensure all existing block configs (doctors, prices, feedbacks, FAQ, contact, blog-grid-with-faq, services, site-settings, scroll-modal) continue to work without any changes
- No block config passes `reorderable` or `paginationType` — they should all default to current behavior (`reorderable: false`, `paginationType: 'page'`)
- TypeScript compilation must pass with no errors

**Rationale:** Spec acceptance criteria: "Existing blocks render unchanged with no prop changes." This is the critical non-regression check.

## Dependencies Between Steps

```
Step 1 (install @dnd-kit)
  └─> Step 7 (use-reorder) ─> Step 8 (reorderable-table) ─> Step 10 (main component)

Step 2 (sort param in useCollectionData)
  └─> Step 5 (use-collection-reference) ─> Step 6 (use-load-more) ─> Step 10

Step 3 (hidePagination on DataTable) ─> Step 10

Step 4 (types) ─> Step 5, 6, 7, 8, 9, 10

Step 9 (load-more-button) ─> Step 10

Step 10 (main component) ─> Step 11 (index.ts) ─> Step 12 (delete old file) ─> Step 13 (field config) ─> Step 14 (importMap) ─> Step 15 (verify)
```

**Parallelizable groups:**
- Steps 1, 2, 3, 4 can all be done in parallel (independent foundations)
- Steps 5, 7, 9 can be done in parallel after Step 4 (independent hooks/components)
- Steps 6, 8 depend on 5 and 7 respectively
- Step 10 depends on all hooks and sub-components
- Steps 11-15 are sequential

## Refactoring Notes

- **`DataTable` modification is minimal** — only adding one optional boolean prop. No structural changes. This keeps the shared component stable.
- **`useCollectionData` modification is additive** — only adding an optional `sort` param. Existing callers are unaffected.
- **Old component file is deleted, not modified** — clean replacement avoids merge confusion.

## Risk Areas

1. **`@dnd-kit` with table rows** — `useSortable` needs to be applied directly to `<tr>` elements. Since `DataTable` owns its `<tr>` rendering, `ReorderableTable` must implement its own table rendering. Risk: visual inconsistency between the two table variants. Mitigation: reuse the same Tailwind classes and rendering patterns from `DataTable`.

2. **Payload importMap regeneration** — If Payload's importMap generator doesn't properly resolve the folder `index.ts`, the component won't load in the admin panel. Mitigation: verify after Step 14; if it fails, adjust the `path` in the field config to explicitly include `/index`.

3. **PATCH concurrency on reorder** — Multiple PATCH requests fire simultaneously. If the API rate-limits or if many items are reordered, some requests may fail. Mitigation: `Promise.allSettled` handles partial failures gracefully, and refetch restores server state.

4. **`load-more` + `reorderable` combination** — Both features modify how data is displayed and managed. The accumulated items array from `useLoadMore` must integrate with `useReorder`'s local ordering. Mitigation: `useReorder` receives `items` as input — it works with whatever array is passed, whether from standard pagination or load-more accumulation.
